<html>
    <head>
        <title>Quadtree_M_Coding</title>
    </head>
    
        <body>
        </body>

        <script>

            //数组a存储原始的矩阵
            var a=[[1,1,1,1,2,2,3,3],
                   [1,1,1,1,2,2,3,3],
                   [1,1,1,1,4,4,5,5],
                   [1,1,1,1,4,4,5,5],
                   [6,6,7,8,13,13,14,14],
                   [6,6,9,10,13,13,14,14],
                   [11,11,12,12,15,16,19,19],
                   [11,11,12,12,17,18,19,19]];
            document.write("矩阵四叉树："+"<br>");

            for(var i=0;i<8;i++)
            {
               for(var j=0;j<8;j++)
               {
                   document.write(a[i][j]+"         ");
               }
               document.write("<br>");
            }

            //数组bb存储M编码
            var bb=[[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]];
            
            create_base(bb);
            every_ceng(a,bb);
            document.write("四进制Morton编码："+"<br>");
            print_Mcode(bb);     
            //判断两数是否相等
            function judge_equal(x,y)
            {
                if(x==y)
                {
                    return 1;
                }
                else
                {
                    return 0;
                }
            }

            //判断数组c表示的矩形范围中数的值是否相同
            function judge_four_equal(a,b,c)
            {
                for(var i=0;i<4;i++)
                {
                    var w=0;
                    for(var m=c[i][0];m<c[i][0]+2;m++)
                    {
                        for(var n=c[i][1];n<c[i][1]+1;n++)
                        {
                            w+=judge_equal(a[m][n],a[m][n+1]);
                        }
                    }
                    //如果4个值属性一样，就把四个都统一为左上角的值
                    if(w==2)
                    {
                        for(var m=c[i][0];m<c[i][0]+2;m++)
                        {
                            for(var n=c[i][1];n<c[i][1]+2;n++)
                            {
                                b[m][n][1]=b[(c[i][0])][(c[i][1])][1];
                                b[m][n][2]=-99;
                            }
                        }
                    }
                }

            }
 
            //进行所有层遍历
            function every_ceng(a,b)
            {
                //第一层
                var c=[[0,0],[0,4],[4,0],[4,4]];
                for(var i=0;i<4;i++)
                {
                    var w=0;
                    for(var m=c[i][0];m<4;m++)
                    {
                        for(var n=c[i][1];n<3;n++)
                        {
                            w+=judge_equal(a[m][n],a[m][n+1]);
                        }
                    }

                    //如果16个值一样，就都赋值为左上角的值
                    if(w==12)
                    {
                        for(var m=c[i][0];m<c[i][0]+4;m++)
                        {
                            for(var n=c[i][1];n<c[i][1]+4;n++)
                            {
                                b[m][n][0]=b[(c[i][0])][(c[i][1])][0];
                                b[m][n][1]=-99;
                                b[m][n][2]=-99;
                            }
                        }
                    }

                }
                //第二层
                var d=[[0,0],[0,2],[2,0],[2,2]];
                var e=[[0,4],[0,6],[2,4],[2,6]];
                var f=[[4,0],[4,2],[6,0],[6,2]];
                var g=[[4,4],[4,6],[6,4],[6,6]];
                judge_four_equal(a,b,d);
                judge_four_equal(a,b,e);
                judge_four_equal(a,b,f);
                judge_four_equal(a,b,g);

                //第三层默认不处理

            }

            //假设每一个数都无法压缩，创建初始完全的三层遍历
            function create_base(b)
            {
                for(var i=0;i<8;i++)
                {
                    for(var j=0;j<8;j++)
                    {
                        if(i<4&j<4)
                        {
                            b[i][j][0]=0;
                        }
                        if(i<4&j>=4)
                        {
                            b[i][j][0]=1;
                        }
                        if(i>=4&j<4)
                        {
                            b[i][j][0]=2;
                        }
                        if(i>=4&j>=4)
                        {
                            b[i][j][0]=3;
                        }

                        if((i==0||i==1||i==4||i==5)&(j==0||j==1||j==4||j==5))
                        {
                            b[i][j][1]=0;
                        }
                        if((i==0||i==1||i==4||i==5)&(j==2||j==3||j==6||j==7))
                        {
                            b[i][j][1]=1;
                        }
                        if((i==2||i==3||i==6||i==7)&(j==0||j==1||j==4||j==5))
                        {
                            b[i][j][1]=2;
                        }
                        if((i==2||i==3||i==6||i==7)&(j==2||j==3||j==6||j==7))
                        {
                            b[i][j][1]=3;
                        }

                        if((i%2==0)&(j%2==0))
                        {
                            b[i][j][2]=0;
                        }
                        if((i%2==0)&(j%2==1))
                        {
                            b[i][j][2]=1;
                        }
                        if((i%2==1)&(j%2==0))
                        {
                            b[i][j][2]=2;
                        }
                        if((i%2==1)&(j%2==1))
                        {
                            b[i][j][2]=3;
                        }

                    }
                }
            }
 
            //打印结果
            function print_Mcode(b)
            {
                var out_string="";
                for(var i=0;i<8;i++)
                {
                    for(var j=0;j<8;j++)
                    {
                        if(b[i][j][1]==-99&b[i][j][2]==-99)
                        {
                            out_string="00"+b[i][j][0].toString()+",1,"+a[i][j].toString();
                        }
                        else if(b[i][j][2]==-99&b[i][j][1]!=-99)
                        {
                            out_string="0"+b[i][j][0].toString()+b[i][j][1].toString()+",2,"+a[i][j].toString();
                        }
                        else
                        {
                            out_string=b[i][j][0].toString()+b[i][j][1].toString()+b[i][j][2].toString()+",3,"+a[i][j].toString();
                        }
                        document.write("("+out_string+")"+"           ");
                    }
                    document.write("<br>");
                }
            }

        </script>

</html>